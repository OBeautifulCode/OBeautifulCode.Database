// --------------------------------------------------------------------------------------------------------------------
// <copyright file="DatabaseHelper.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Database.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Database.Recipes
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.Data.SqlTypes;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Threading.Tasks;

    using OBeautifulCode.Assertion.Recipes;
    using OBeautifulCode.Collection.Recipes;
    using OBeautifulCode.String.Recipes;
    using OBeautifulCode.Type.Recipes;
    using static System.FormattableString;

    /// <summary>
    /// Provides various methods for interacting with a database.
    /// </summary>
#if !OBeautifulCodeDatabaseRecipesProject
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Database.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static class DatabaseHelper
    {
        private static readonly IReadOnlyCollection<SqlDbType> ValidStringSqlDbTypes = new[] { SqlDbType.Char, SqlDbType.NChar, SqlDbType.VarChar, SqlDbType.NVarChar, SqlDbType.Xml };

        private static readonly IReadOnlyCollection<SqlDbType> ValidByteArraySqlDbTypes = new[] { SqlDbType.Binary, SqlDbType.VarBinary };

        private static readonly IReadOnlyCollection<SqlDbType> ValidDecimalSqlDbTypes = new[] { SqlDbType.Decimal, SqlDbType.Money, SqlDbType.SmallMoney };

        /// <summary>
        /// Opens a SQL Server database connection using a connection string.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <returns>
        /// An open SQL Server connection.
        /// </returns>
        public static SqlConnection OpenSqlConnection(
            this string connectionString)
        {
            new { connectionString }.AsArg().Must().NotBeNullNorWhiteSpace();

            SqlConnection result = null;

            try
            {
                // an invalid connectionString will throw ArgumentException.
                result = new SqlConnection { ConnectionString = connectionString };

                // InvalidOperationException won't be thrown, even if data source or server aren't specified
                // in the connection string.  as long as the connection string is valid,
                // the only possible exception is SqlException
                result.Open();
            }
            catch (Exception)
            {
                result?.Dispose();

                throw;
            }

            return result;
        }

        /// <summary>
        /// Opens a SQL Server database connection using a connection string.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <returns>
        /// An open SQL Server connection.
        /// </returns>
        public static async Task<SqlConnection> OpenSqlConnectionAsync(
            this string connectionString)
        {
            new { connectionString }.AsArg().Must().NotBeNullNorWhiteSpace();

            SqlConnection result = null;

            try
            {
                // an invalid connectionString will throw ArgumentException.
                result = new SqlConnection { ConnectionString = connectionString };

                // InvalidOperationException won't be thrown, even if data source or server aren't specified
                // in the connection string.  as long as the connection string is valid,
                // the only possible exception is SqlException
                await result.OpenAsync();
            }
            catch (Exception)
            {
                result?.Dispose();

                throw;
            }

            return result;
        }

        /// <summary>
        /// Builds a <see cref="SqlCommand"/> using an existing database connection.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The constructed <see cref="SqlCommand"/>.
        /// </returns>
        [SuppressMessage("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities", Justification = "It's convenient to execute a string command and this method does have a parameter for command parameters.")]
        public static SqlCommand BuildSqlCommand(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            bool prepareCommand = false)
        {
            // check arguments
            new { connection }.AsArg().Must().NotBeNull();
            new { connection.State }.AsArg().Must().BeEqualTo(ConnectionState.Open, "connection is in an invalid state: " + connection.State + ".  Must be Open.");
            new { commandText }.AsArg().Must().NotBeNullNorWhiteSpace();
            new { commandTimeoutInSeconds }.AsArg().Must().BeGreaterThanOrEqualTo(0);
            commandParameters = commandParameters ?? new SqlParameter[0];
            new { commandParameters }.AsArg().Must().NotContainAnyNullElements();

            // validate transaction
            if (transaction != null)
            {
                if (transaction.Connection == null)
                {
                    throw new ArgumentException(Invariant($"{nameof(transaction)} is invalid; its {nameof(SqlTransaction.Connection)} is null."));
                }

                if (transaction.Connection != connection)
                {
                    throw new ArgumentException(Invariant($"{nameof(transaction)} is using a different {nameof(SqlTransaction.Connection)} than the specified {nameof(connection)}."));
                }
            }

            // create the command.  documentation indicates that this will not throw
            var result = connection.CreateCommand();

            try
            {
                // populate command properties
                result.Connection = connection;
                result.CommandType = commandType;
                result.CommandText = commandText;
                result.CommandTimeout = commandTimeoutInSeconds;

                if (transaction != null)
                {
                    result.Transaction = transaction;
                }

                foreach (var parameter in commandParameters)
                {
                    result.Parameters.Add(parameter);
                }

                if (prepareCommand)
                {
                    result.Prepare();
                }

                return result;
            }
            catch (Exception)
            {
                result.Dispose();

                throw;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/>, and builds an <see cref="SqlDataReader"/>.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <remarks>
        /// If an expected parameter type does not match an actual parameter value's type, ExecuteReader() does not throw <see cref="SqlException"/>.
        /// Instead, a reader with no rows is returned.  Any attempt to Read() will throw an exception.
        /// </remarks>
        /// <returns>
        /// A constructed <see cref="SqlDataReader"/>.
        /// </returns>
        public static SqlDataReader ExecuteReader(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false)
        {
            if (!commandBehavior.HasFlag(CommandBehavior.CloseConnection))
            {
                throw new ArgumentException(Invariant($"{nameof(commandBehavior)} does not set the flag {CommandBehavior.CloseConnection}.  This will result in an open connection with the caller having no means of closing it."));
            }

            var connection = OpenSqlConnection(connectionString);

            var result = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, null, commandBehavior, prepareCommand);

            return result;
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and builds an <see cref="SqlDataReader"/>.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <remarks>
        /// If an expected parameter type does not match an actual parameter value's type, ExecuteReader() does not throw <see cref="SqlException"/>.
        /// Instead, a reader with no rows is returned.  Any attempt to Read() will throw an exception.
        /// </remarks>
        /// <returns>
        /// A constructed <see cref="SqlDataReader"/>.
        /// </returns>
        public static SqlDataReader ExecuteReader(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var command = connection.BuildSqlCommand(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, prepareCommand))
            {
                var result = command.ExecuteReader(commandBehavior);  // can throw SqlException

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> and returns the number of rows affected.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The number of rows affected.
        /// </returns>
        public static int ExecuteNonQuery(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            bool prepareCommand = false)
        {
            using (var connection = connectionString.OpenSqlConnection())
            {
                var result = connection.ExecuteNonQuery(commandText, commandTimeoutInSeconds, commandParameters, commandType, null, prepareCommand);

                connection.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns the number of rows affected.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The number of rows affected.
        /// </returns>
        public static int ExecuteNonQuery(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            bool prepareCommand = false)
        {
            using (var command = connection.BuildSqlCommand(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, prepareCommand))
            {
                var result = command.ExecuteNonQuery();  // can throw SqlException

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes <paramref name="batchCommandText"/>, and returns the number of rows affected for each individual command.
        /// </summary>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="batchCommandText">The batch SQL command to execute.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <remarks>
        /// This method does not support parameters.  Parameter object must be unique per command - parameters cannot be reused across commands.
        /// All commands in the batch are expected to be Text commands.
        /// </remarks>
        /// <returns>
        /// The number of rows affected for each individual command that is executed.
        /// </returns>
        public static IReadOnlyList<int> ExecuteNonQueryBatch(
            this string connectionString,
            string batchCommandText,
            int commandTimeoutInSeconds = 30)
        {
            new { batchCommandText }.AsArg().Must().NotBeNullNorWhiteSpace();

            var statements = SqlBatchStatementSplitter.SplitSqlAndRemoveEmptyStatements(batchCommandText);

            if (!statements.Any())
            {
                throw new InvalidOperationException(Invariant($"No individual commands found in {nameof(batchCommandText)}."));
            }

            using (var connection = connectionString.OpenSqlConnection())
            {
                var result = connection.ExecuteNonQueryBatch(batchCommandText, commandTimeoutInSeconds);

                connection.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="batchCommandText"/> against the <paramref name="connection"/> and returns the number of rows affected for each individual command.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="batchCommandText">The batch SQL command to execute.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <remarks>
        /// This method does not support parameters.  Parameter object must be unique per command - parameters cannot be reused across commands.
        /// All commands in the batch are expected to be Text commands.
        /// </remarks>
        /// <returns>
        /// The number of rows affected for each individual command that is executed.
        /// </returns>
        public static IReadOnlyList<int> ExecuteNonQueryBatch(
            this SqlConnection connection,
            string batchCommandText,
            int commandTimeoutInSeconds = 30,
            SqlTransaction transaction = null)
        {
            new { batchCommandText }.AsArg().Must().NotBeNullNorWhiteSpace();

            var statements = SqlBatchStatementSplitter.SplitSqlAndRemoveEmptyStatements(batchCommandText);

            if (!statements.Any())
            {
                throw new InvalidOperationException(Invariant($"no individual commands found in {nameof(batchCommandText)}"));
            }

            var result = new List<int>();

            foreach (var statement in statements)
            {
                var rowsAffected = connection.ExecuteNonQuery(statement, commandTimeoutInSeconds);

                result.Add(rowsAffected);
            }

            return result;
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/>,
        /// and determines if reading from the <see cref="SqlDataReader"/> results in at least one row of data.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// true if executing the command results in at least one row of data; otherwise false.
        /// </returns>
        public static bool HasAtLeastOneRowWhenReading(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false)
        {
            using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand))
            {
                var result = reader.Read();

                reader.Close();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/>
        /// and determines if reading from the <see cref="SqlDataReader"/> results in at least one row of data.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// true if executing the command results in at least one row of data; otherwise false.
        /// </returns>
        public static bool HasAtLeastOneRowWhenReading(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = reader.Read();

                reader.Close();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns a single column of values.
        /// Throws if the query results in 0 or multiple columns.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The results of the query in the order their were returned from the database.
        /// </returns>
        public static IReadOnlyList<object> ReadSingleColumn(
            this string connectionString,
            string commandText,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            bool prepareCommand = false,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            int commandTimeoutInSeconds = 30)
        {
            using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand))
            {
                var result = reader.ReadSingleColumnInternal();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns a single column of values.
        /// Throws if the query results in 0 or multiple columns.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The results of the query in the order their were returned from the database.
        /// </returns>
        public static IReadOnlyList<object> ReadSingleColumn(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = reader.ReadSingleColumnInternal();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns the resulting value.
        /// Throws if there are no rows, multiple rows, no columns, or multiple columns.
        /// This is a more restrictive version of <see cref="SqlCommand.ExecuteScalar"/>.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The resulting value.
        /// </returns>
        public static object ReadSingleValue(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false)
        {
            using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand))
            {
                var result = reader.ReadSingleValueInternal();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns the resulting value.
        /// Throws if there are no rows, multiple rows, no columns, or multiple columns.
        /// This is a more restrictive version of <see cref="SqlCommand.ExecuteScalar"/>.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// The resulting value.
        /// </returns>
        public static object ReadSingleValue(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = reader.ReadSingleValueInternal();

                return result;
            }
        }
        
        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/> against the connection, and returns a single row of values.
        /// Throws if there are no rows, multiple rows, or multiple columns with the same case-insensitive name.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// A dictionary where the keys are column names (case insensitive) and values are the values of the single row returned by the query.
        /// </returns>
        public static IReadOnlyDictionary<string, object> ReadSingleRow(
            this string connectionString,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false)
        {
            using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand))
            {
                var result = reader.ReadSingleRowInternal();

                return result;
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and returns a single row of values.
        /// Throws if there are no rows, multiple rows, or multiple columns with the same case-insensitive name.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        /// <returns>
        /// A dictionary where the keys are column names (case insensitive) and values are the values of the single row returned by the query.
        /// </returns>
        public static IReadOnlyDictionary<string, object> ReadSingleRow(
            this SqlConnection connection,
            string commandText,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            using (var reader = connection.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
            {
                var result = reader.ReadSingleRowInternal();

                return result;
            }
        }

        /// <summary>
        /// Opens a connection to the database, executes the <paramref name="commandText"/>, and writes the results to a CSV file.
        /// </summary>
        /// <remarks>
        /// Sets CommandBehavior = CommandBehavior.CloseConnection so that the created connection is closed when the data reader is closed.
        /// </remarks>
        /// <param name="connectionString">String used to open a connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="outputFilePath">Path to file where CSV data should be written.</param>
        /// <param name="includeColumnNames">Indicates whether the first row should be populated with column names.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        public static void WriteToCsv(
            this string connectionString,
            string commandText,
            string outputFilePath,
            bool includeColumnNames = true,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            CommandBehavior commandBehavior = CommandBehavior.CloseConnection,
            bool prepareCommand = false)
        {
            new { outputFilePath }.AsArg().Must().NotBeNullNorWhiteSpace();

            using (var writer = new StreamWriter(outputFilePath))
            {
                using (var reader = connectionString.ExecuteReader(commandText, commandTimeoutInSeconds, commandParameters, commandType, commandBehavior, prepareCommand))
                {
                    reader.WriteToCsv(writer, includeColumnNames);
                }
            }
        }

        /// <summary>
        /// Executes the <paramref name="commandText"/> against the <paramref name="connection"/> and writes the results to a CSV file.
        /// </summary>
        /// <param name="connection">An open connection to the database.</param>
        /// <param name="commandText">The SQL statement, table name, or stored procedure to execute at the data source.</param>
        /// <param name="outputFilePath">Path to file where CSV data should be written.</param>
        /// <param name="includeColumnNames">Indicates whether the first row should be populated with column names.</param>
        /// <param name="commandTimeoutInSeconds">OPTIONAL value with the wait time, in seconds, before terminating an attempt to execute the command and generating an error.  DEFAULT is 30 seconds.  A value of 0 indicates no limit (an attempt to execute a command will wait indefinitely).</param>
        /// <param name="commandParameters">OPTIONAL set of parameters to associate with the command.  DEFAULT is null (no parameters).</param>
        /// <param name="commandType">OPTIONAL value that determines how the command text is to be interpreted.  DEFAULT is <see cref="CommandType.Text"/>; a SQL text command.</param>
        /// <param name="transaction">OPTIONAL transaction within which the command will execute.  DEFAULT is null (no transaction).</param>
        /// <param name="commandBehavior">OPTIONAL value providing a description of the results of the query and its effect on the database.  DEFAULT is <see cref="CommandBehavior.Default"/>; the query may return multiple result sets and execution of the query may affect the database state.  This enumeration has a FlagsAttribute attribute that allows a bitwise combination of its member values.</param>
        /// <param name="prepareCommand">OPTIONAL value indicating whether to prepared (or compile) the command on the data source.</param>
        public static void WriteToCsv(
            this SqlConnection connection,
            string commandText,
            string outputFilePath,
            bool includeColumnNames = true,
            int commandTimeoutInSeconds = 30,
            IReadOnlyList<SqlParameter> commandParameters = null,
            CommandType commandType = CommandType.Text,
            SqlTransaction transaction = null,
            CommandBehavior commandBehavior = CommandBehavior.Default,
            bool prepareCommand = false)
        {
            new { outputFilePath }.AsArg().Must().NotBeNullNorWhiteSpace();

            using (var writer = new StreamWriter(outputFilePath))
            {
                using (var reader = ExecuteReader(connection, commandText, commandTimeoutInSeconds, commandParameters, commandType, transaction, commandBehavior, prepareCommand))
                {
                    reader.WriteToCsv(writer, includeColumnNames);
                }
            }
        }

        /// <summary>
        /// Rollback a transaction with the proper error handling.
        /// </summary>
        /// <param name="transaction">The transaction to rollback.</param>
        public static void RollbackTransaction(
            this SqlTransaction transaction)
        {
            new { transaction }.AsArg().Must().NotBeNull();

            if (transaction.Connection == null)
            {
                // try to detect invalid transaction before calling transaction.Rollback()
                throw new InvalidOperationException("Could not roll back transaction " + transaction + " because the the transaction has already been committed or rolled back -or- the connection is broken.");
            }

            try
            {
                transaction.Rollback();
            }
            catch (InvalidOperationException)
            {
                // the transaction has already been committed or rolled back -or- the connection is broken.
                throw;
            }
            catch (Exception rollbackException)
            {
                throw new InvalidOperationException("Failed to rollback transaction.", rollbackException);
            }
        }

        /// <summary>
        /// Returns the bit representation of a boolean.
        /// </summary>
        /// <param name="value">The boolean to evaluate.</param>
        /// <returns>
        /// "1" if boolean is true, "0" if boolean is false.
        /// </returns>
        public static string ToBit(
            this bool value)
        {
            return value ? "1" : "0";
        }

        // IsNullable does nothing https://stackoverflow.com/questions/5821850/what-is-the-purpose-of-system-data-sqlclient-sqlparameter-isnullable
        // good article: https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/sql-server-data-types?view=netframework-4.8
        // https://stackoverflow.com/questions/4624811/when-should-sqldbtype-and-size-be-used-when-adding-sqlcommand-parameters

        // validate that output parameters are only used with stored procedures
        // disallow input/output parameters
        // disallow return parameters



        /// <summary>
        /// Creates an input parameter for the specified <see cref="string"/> value.
        /// </summary>
        /// <remarks>
        /// <see cref="SqlDbType.Text"/> and <see cref="SqlDbType.NText"/> have been deprecated.
        /// <see cref="SqlParameter.Offset"/> doesn't seem to work for strings.  Ran numerous tests with both input and output
        /// parameters, combined with and without using <see cref="SqlParameter.Size"/> and either the framework throws or just returns
        /// the entire string.
        /// Did not dig into <see cref="SqlParameter.CompareInfo"/> and <see cref="SqlParameter.LocaleId"/>, which both seem to applicable
        /// to strings.
        /// </remarks>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="sqlDbType">
        /// OPTIONAL the SQL Server data type to convert the parameter value into.  DEFAULT is <see cref="SqlDbType.NVarChar"/>.
        /// Must be one of:
        /// <see cref="SqlDbType.Char"/>
        /// <see cref="SqlDbType.NChar"/>
        /// <see cref="SqlDbType.VarChar"/>
        /// <see cref="SqlDbType.NVarChar"/>
        /// <see cref="SqlDbType.Xml"/>
        /// </param>
        /// <param name="size">
        /// OPTIONAL maximum size, in bytes or characters (depending on the value of <paramref name="sqlDbType"/>) to transmit to the server.
        /// DEFAULT is null (use the size of <paramref name="value"/>).
        /// If specified, must be &gt;= -1.
        /// If size of <paramref name="value"/> is greater than the specified <paramref name="size"/> then it will be truncated.
        /// For <see cref="SqlDbType.Char"/>, <see cref="SqlDbType.VarChar"/> this parameter specifies the number of bytes.
        /// For <see cref="SqlDbType.NChar"/>, <see cref="SqlDbType.NVarChar"/> this parameter specifies the number of characters.
        /// The count for strings does not include the terminating character.
        /// Setting a size with <see cref="SqlDbType.Xml"/> will throw; truncating XML results in invalid XML.
        /// -1 or 0 are ignored, they do not cause any truncation.
        /// </param>
        /// <param name="coalesceNullToDbNull">
        /// OPTIONAL value indicating whether to coalesce null to <see cref="DBNull.Value"/>.  DEFAULT is true.
        /// The only time when this should be false is if you are calling a stored procedure and want to use the default value
        /// for the parameter defined in the stored procedure, instead of passing a null value.
        /// </param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this string value,
            string name,
            SqlDbType sqlDbType = SqlDbType.NVarChar,
            int? size = null,
            bool coalesceNullToDbNull = true)
        {
            name.ValidateForSqlParameterName();
            sqlDbType.ValidateForSqlDbType(ValidStringSqlDbTypes);
            if ((sqlDbType == SqlDbType.Xml) && (size != null))
            {
                throw new ArgumentException(Invariant($"{nameof(sqlDbType)} is {nameof(SqlDbType.Xml)} and {nameof(size)} is not null.  Truncating XML makes no sense."));
            }

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = sqlDbType,
            };

            if (coalesceNullToDbNull)
            {
                result.Value = value ?? (object)DBNull.Value;
            }
            else
            {
                result.Value = value;
            }

            if (size != null)
            {
                // setting to < -1 will throw
                result.Size = (int)size;
            }

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a <see cref="string"/> value.
        /// </summary>
        /// <remarks>
        /// <see cref="SqlDbType.Text"/> and <see cref="SqlDbType.NText"/> have been deprecated.
        /// <see cref="SqlParameter.Offset"/> doesn't seem to work for strings.  Ran numerous tests with both input and output
        /// parameters, combined with and without using <see cref="SqlParameter.Size"/> and either the framework throws or just returns
        /// the entire string.
        /// Did not dig into <see cref="SqlParameter.LocaleId"/>, which seems to applicable to strings.
        /// Unsure if <see cref="SqlParameter.CompareInfo"/> is applicable for output parameters.
        /// </remarks>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="sqlDbType">
        /// OPTIONAL the SQL Server data type to convert the parameter value into.  DEFAULT is <see cref="SqlDbType.NVarChar"/>.
        /// Must be one of:
        /// <see cref="SqlDbType.Char"/>
        /// <see cref="SqlDbType.NChar"/>
        /// <see cref="SqlDbType.VarChar"/>
        /// <see cref="SqlDbType.NVarChar"/>
        /// <see cref="SqlDbType.Xml"/>
        /// </param>
        /// <param name="size">
        /// Maximum size, in bytes or characters (depending on the value of <paramref name="sqlDbType"/>) to receive from the server.
        /// DEFAULT is -1 (no size constraint; return the entire string).
        /// This parameter is required; if not set in the <see cref="SqlParameter"/> then the default(int) value of 0 will throw.
        /// If size of value on the server is greater than the specified <paramref name="size"/> then it will be truncated.
        /// For <see cref="SqlDbType.Char"/>, <see cref="SqlDbType.VarChar"/> this parameter specifies the number of bytes.
        /// For <see cref="SqlDbType.NChar"/>, <see cref="SqlDbType.NVarChar"/> this parameter specifies the number of characters.
        /// The count for strings does not include the terminating character.
        /// Setting a size for <see cref="SqlDbType.Xml"/> does nothing.
        /// </param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputStringSqlParameter(
            string name,
            SqlDbType sqlDbType = SqlDbType.NVarChar,
            int size = -1)
        {
            name.ValidateForSqlParameterName();
            sqlDbType.ValidateForSqlDbType(ValidStringSqlDbTypes);

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = sqlDbType,
                Size = size,
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified <see cref="Array"/> of <see cref="byte"/> value.
        /// </summary>
        /// <remarks>
        /// <see cref="SqlDbType.Image"/> has been deprecated.
        /// </remarks>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="sqlDbType">
        /// OPTIONAL the SQL Server data type to convert the parameter value into.  DEFAULT is <see cref="SqlDbType.VarBinary"/>.
        /// Must be one of:
        /// <see cref="SqlDbType.Binary"/>
        /// <see cref="SqlDbType.VarBinary"/>
        /// </param>
        /// <param name="size">
        /// OPTIONAL maximum number of bytes to transmit to the server.  DEFAULT is null (use the size of <paramref name="value"/>).
        /// If size of <paramref name="value"/> is greater than the specified <paramref name="size"/> then it will be truncated.
        /// -1 or 0 are ignored, they do not cause any truncation.
        /// </param>
        /// <param name="offset">
        /// OPTIONAL index in the byte array to start transmitting at.  DEFAULT is null (transmit starting at the first byte).
        /// If specified, then must be &gt;= 0 and &lt; the length of <paramref name="value"/>. 
        /// If specified, then <paramref name="size"/> must be &gt; 0 and &lt;= the length of <paramref name="value"/> - this offset.
        /// </param>
        /// <param name="coalesceNullToDbNull">
        /// OPTIONAL value indicating whether to coalesce null to <see cref="DBNull.Value"/>.  DEFAULT is true.
        /// The only time when this should be false is if you are calling a stored procedure and want to use the default value
        /// for the parameter defined in the stored procedure, instead of passing a null value.
        /// </param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this byte[] value,
            string name,
            SqlDbType sqlDbType = SqlDbType.VarBinary,
            int? size = null,
            int? offset = null,
            bool coalesceNullToDbNull = true)
        {
            name.ValidateForSqlParameterName();
            sqlDbType.ValidateForSqlDbType(ValidByteArraySqlDbTypes);

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = sqlDbType,
            };

            if (coalesceNullToDbNull)
            {
                result.Value = value ?? (object)DBNull.Value;
            }
            else
            {
                result.Value = value;
            }

            if (size != null)
            {
                // setting to < -1 will throw
                result.Size = (int)size;
            }

            if (offset != null)
            {
                // setting to < 0 will throw
                result.Offset = (int)offset;
            }
            
            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch an <see cref="Array"/> of <see cref="byte"/> value.
        /// </summary>
        /// <remarks>
        /// <see cref="SqlDbType.Image"/> has been deprecated.
        /// Oddly, <see cref="SqlParameter.Offset"/> is ignored for output parameters.  Use other means to chunk/stream binary data.
        /// </remarks>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="sqlDbType">
        /// OPTIONAL the SQL Server data type to convert the parameter value into.  DEFAULT is <see cref="SqlDbType.VarBinary"/>.
        /// Must be one of:
        /// <see cref="SqlDbType.Binary"/>
        /// <see cref="SqlDbType.VarBinary"/>
        /// </param>
        /// <param name="size">
        /// For <see cref="SqlDbType.Binary"/>, the number of bytes to receive from the server, padding with 0's if the payload size is less than the specified size.
        /// For <see cref="SqlDbType.VarBinary"/>, the maximum number of bytes to receive from the server.
        /// DEFAULT is -1 (no constraint; return all of the bytes).
        /// This parameter is required; if not set in the <see cref="SqlParameter"/> then the default(int) value of 0 will throw.
        /// If size of the value on the server is greater than the specified <paramref name="size"/> then it will be truncated.
        /// </param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputByteArraySqlParameter(
            string name,
            SqlDbType sqlDbType = SqlDbType.VarBinary,
            int size = -1)
        {
            name.ValidateForSqlParameterName();
            sqlDbType.ValidateForSqlDbType(ValidByteArraySqlDbTypes);

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = sqlDbType,
                Size = size,
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified <see cref="byte"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this byte value,
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.TinyInt,
                Value = value
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified nullable <see cref="byte"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="coalesceNullToDbNull">
        /// OPTIONAL value indicating whether to coalesce null to <see cref="DBNull.Value"/>.  DEFAULT is true.
        /// The only time when this should be false is if you are calling a stored procedure and want to use the default value
        /// for the parameter defined in the stored procedure, instead of passing a null value.
        /// </param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this byte? value,
            string name,
            bool coalesceNullToDbNull = true)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.TinyInt,
            };

            if (coalesceNullToDbNull)
            {
                result.Value = value ?? (object)DBNull.Value;
            }
            else
            {
                result.Value = value;
            }

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a <see cref="byte"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputByteSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.TinyInt,
            };

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a nullable <see cref="byte"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputNullableByteSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.TinyInt,
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified <see cref="short"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this short value,
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.SmallInt,
                Value = value
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified nullable <see cref="short"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="coalesceNullToDbNull">
        /// OPTIONAL value indicating whether to coalesce null to <see cref="DBNull.Value"/>.  DEFAULT is true.
        /// The only time when this should be false is if you are calling a stored procedure and want to use the default value
        /// for the parameter defined in the stored procedure, instead of passing a null value.
        /// </param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this short? value,
            string name,
            bool coalesceNullToDbNull = true)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.SmallInt,
            };

            if (coalesceNullToDbNull)
            {
                result.Value = value ?? (object)DBNull.Value;
            }
            else
            {
                result.Value = value;
            }

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a <see cref="short"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputShortSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.SmallInt,
            };

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a nullable <see cref="short"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputNullableShortSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.SmallInt,
            };

            return result;
        }
        
        /// <summary>
        /// Creates an input parameter for the specified <see cref="int"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this int value,
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.Int,
                Value = value
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified nullable <see cref="int"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="coalesceNullToDbNull">
        /// OPTIONAL value indicating whether to coalesce null to <see cref="DBNull.Value"/>.  DEFAULT is true.
        /// The only time when this should be false is if you are calling a stored procedure and want to use the default value
        /// for the parameter defined in the stored procedure, instead of passing a null value.
        /// </param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this int? value,
            string name,
            bool coalesceNullToDbNull = true)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.Int,
            };

            if (coalesceNullToDbNull)
            {
                result.Value = value ?? (object)DBNull.Value;
            }
            else
            {
                result.Value = value;
            }

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a <see cref="int"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputIntSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.Int,
            };

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a nullable <see cref="int"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputNullableIntSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.Int,
            };

            return result;
        }
        
        /// <summary>
        /// Creates an input parameter for the specified <see cref="long"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this long value,
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.BigInt,
                Value = value
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified nullable <see cref="long"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="coalesceNullToDbNull">
        /// OPTIONAL value indicating whether to coalesce null to <see cref="DBNull.Value"/>.  DEFAULT is true.
        /// The only time when this should be false is if you are calling a stored procedure and want to use the default value
        /// for the parameter defined in the stored procedure, instead of passing a null value.
        /// </param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this long? value,
            string name,
            bool coalesceNullToDbNull = true)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.BigInt,
            };

            if (coalesceNullToDbNull)
            {
                result.Value = value ?? (object)DBNull.Value;
            }
            else
            {
                result.Value = value;
            }

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a <see cref="int"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputLongSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.BigInt,
            };

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a nullable <see cref="int"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputNullableLongSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.BigInt,
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified <see cref="bool"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this bool value,
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.Bit,
                Value = value
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified nullable <see cref="bool"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="coalesceNullToDbNull">
        /// OPTIONAL value indicating whether to coalesce null to <see cref="DBNull.Value"/>.  DEFAULT is true.
        /// The only time when this should be false is if you are calling a stored procedure and want to use the default value
        /// for the parameter defined in the stored procedure, instead of passing a null value.
        /// </param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this bool? value,
            string name,
            bool coalesceNullToDbNull = true)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.Bit,
            };

            if (coalesceNullToDbNull)
            {
                result.Value = value ?? (object)DBNull.Value;
            }
            else
            {
                result.Value = value;
            }

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a <see cref="bool"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputBoolSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.Bit,
            };

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a nullable <see cref="bool"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputNullableBoolSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.Bit,
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified <see cref="Guid"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this Guid value,
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.UniqueIdentifier,
                Value = value
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified nullable <see cref="Guid"/> value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="coalesceNullToDbNull">
        /// OPTIONAL value indicating whether to coalesce null to <see cref="DBNull.Value"/>.  DEFAULT is true.
        /// The only time when this should be false is if you are calling a stored procedure and want to use the default value
        /// for the parameter defined in the stored procedure, instead of passing a null value.
        /// </param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this Guid? value,
            string name,
            bool coalesceNullToDbNull = true)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = SqlDbType.UniqueIdentifier,
            };

            if (coalesceNullToDbNull)
            {
                result.Value = value ?? (object)DBNull.Value;
            }
            else
            {
                result.Value = value;
            }

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a <see cref="Guid"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputGuidSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.UniqueIdentifier,
            };

            return result;
        }

        /// <summary>
        /// Creates an output parameter to fetch a nullable <see cref="Guid"/> value.
        /// </summary>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <returns>
        /// The output parameter.
        /// </returns>
        public static SqlParameter CreateOutputNullableGuidSqlParameter(
            string name)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = SqlDbType.UniqueIdentifier,
            };

            return result;
        }
        
        /// <summary>
        /// Creates an input parameter for the specified <see cref="decimal"/> value.
        /// </summary>
        /// <remarks>
        /// In practice, <see cref="SqlParameter.Precision"/> and <see cref="SqlParameter.Scale"/> can be used to coerce data
        /// passed to the database, however the documentation for these properties states
        /// "Use of this property to coerce data passed to the database is not supported. To round, truncate, or otherwise
        /// coerce data before passing it to the database, use the Math class..."
        /// For this reason, we don't expose these as parameters.
        /// </remarks>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="sqlDbType">
        /// OPTIONAL the SQL Server data type to convert the parameter value into.  DEFAULT is <see cref="SqlDbType.Decimal"/>.
        /// Must be one of:
        /// <see cref="SqlDbType.Decimal"/>
        /// <see cref="SqlDbType.SmallMoney"/>
        /// <see cref="SqlDbType.Money"/>
        /// </param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this decimal value,
            string name,
            SqlDbType sqlDbType = SqlDbType.Decimal)
        {
            name.ValidateForSqlParameterName();
            sqlDbType.ValidateForSqlDbType(ValidDecimalSqlDbTypes);

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = sqlDbType,
                Value = value
            };

            return result;
        }

        /// <summary>
        /// Creates an input parameter for the specified nullable <see cref="decimal"/> value.
        /// </summary>
        /// <remarks>
        /// In practice, <see cref="SqlParameter.Precision"/> and <see cref="SqlParameter.Scale"/> can be used to coerce data
        /// passed to the database, however the documentation for these properties states
        /// "Use of this property to coerce data passed to the database is not supported. To round, truncate, or otherwise
        /// coerce data before passing it to the database, use the Math class..."
        /// For this reason, we don't expose these as parameters.
        /// </remarks>
        /// <param name="value">The value.</param>
        /// <param name="name">The name of the parameter.  Must be alpha-numeric, but can start with '@'.</param>
        /// <param name="sqlDbType">
        /// OPTIONAL the SQL Server data type to convert the parameter value into.  DEFAULT is <see cref="SqlDbType.Decimal"/>.
        /// Must be one of:
        /// <see cref="SqlDbType.Decimal"/>
        /// <see cref="SqlDbType.SmallMoney"/>
        /// <see cref="SqlDbType.Money"/>
        /// </param>
        /// <param name="coalesceNullToDbNull">
        /// OPTIONAL value indicating whether to coalesce null to <see cref="DBNull.Value"/>.  DEFAULT is true.
        /// The only time when this should be false is if you are calling a stored procedure and want to use the default value
        /// for the parameter defined in the stored procedure, instead of passing a null value.
        /// </param>
        /// <returns>
        /// The input parameter.
        /// </returns>
        public static SqlParameter CreateInputSqlParameter(
            this decimal? value,
            string name,
            SqlDbType sqlDbType = SqlDbType.Decimal,
            bool coalesceNullToDbNull = true)
        {
            name.ValidateForSqlParameterName();
            sqlDbType.ValidateForSqlDbType(ValidDecimalSqlDbTypes);

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = sqlDbType,
            };

            if (coalesceNullToDbNull)
            {
                result.Value = value ?? (object)DBNull.Value;
            }
            else
            {
                result.Value = value;
            }

            return result;
        }





        public static SqlParameter CreateOutputDecimalSqlParameter(
            string name,
            SqlDbType sqlDbType = SqlDbType.Decimal,
            byte? precision = null,
            byte? scale = null)
        {
            name.ValidateForSqlParameterName();
            sqlDbType.ValidateForSqlDbType(ValidDecimalSqlDbTypes);

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = sqlDbType,
            };

            if (precision != null)
            {
                result.Precision = (byte)precision;
            }

            if (scale != null)
            {
                result.Scale = (byte)scale;
            }

            return result;
        }

        public static SqlParameter CreateOutputNullableDecimalSqlParameter(
            string name,
            SqlDbType sqlDbType = SqlDbType.Decimal,
            byte? precision = null,
            byte? scale = null)
        {
            name.ValidateForSqlParameterName();
            sqlDbType.ValidateForSqlDbType(ValidDecimalSqlDbTypes);

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = sqlDbType,
            };

            if (precision != null)
            {
                result.Precision = (byte)precision;
            }

            if (scale != null)
            {
                result.Scale = (byte)scale;
            }

            return result;
        }






        public static SqlParameter CreateInputSqlParameter(
            this DateTime value,
            string name,
            SqlDbType sqlDbType = SqlDbType.DateTime2)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = sqlDbType,
                Value = value
            };

            return result;
        }

        public static SqlParameter CreateInputSqlParameter(
            this DateTime? value,
            string name,
            SqlDbType sqlDbType = SqlDbType.DateTime2)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Input,
                ParameterName = name,
                SqlDbType = sqlDbType,
                Value = value ?? (object)DBNull.Value,
            };

            result.Value = value;

            return result;
        }

        public static SqlParameter CreateOutputDateTimeSqlParameter(
            string name,
            SqlDbType sqlDbType = SqlDbType.DateTime2,
            byte? scale = null)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = sqlDbType,
            };

            if (scale != null)
            {
                result.Scale = (byte)scale;
            }

            return result;
        }

        public static SqlParameter CreateOutputNullableDateTimeSqlParameter(
            string name,
            SqlDbType sqlDbType = SqlDbType.DateTime2,
            byte? scale = null)
        {
            name.ValidateForSqlParameterName();

            var result = new SqlParameter
            {
                Direction = ParameterDirection.Output,
                ParameterName = name,
                SqlDbType = sqlDbType,
            };

            if (scale != null)
            {
                result.Scale = (byte)scale;
            }

            return result;
        }
        




        private static IReadOnlyList<object> ReadSingleColumnInternal(
            this SqlDataReader reader)
        {
            try
            {
                var result = new List<object>();

                if (reader.FieldCount == 0)
                {
                    throw new InvalidOperationException("Query results in no columns.");
                }

                if (reader.FieldCount != 1)
                {
                    throw new InvalidOperationException("Query results in more than one column.");
                }

                while (reader.Read())
                {
                    result.Add(reader.IsDBNull(0) ? null : reader[0]);
                }

                return result;
            }
            finally
            {
                reader.Close();
            }
        }

        private static object ReadSingleValueInternal(
            this SqlDataReader reader)
        {
            try
            {
                if (!reader.Read())
                {
                    throw new InvalidOperationException("Query results in no rows.");
                }

                if (reader.FieldCount == 0)
                {
                    throw new InvalidOperationException("Query results in no columns.");
                }

                if (reader.FieldCount != 1)
                {
                    throw new InvalidOperationException("Query results in more than one column.");
                }

                object result = null;

                if (!reader.IsDBNull(0))
                {
                    result = reader[0];
                }

                if (reader.Read())
                {
                    throw new InvalidOperationException("Query results in more than one row.");
                }

                return result;
            }
            finally
            {
                reader.Close();
            }
        }

        private static IReadOnlyDictionary<string, object> ReadSingleRowInternal(
            this SqlDataReader reader)
        {
            try
            {
                if (!reader.Read())
                {
                    throw new InvalidOperationException("Query results in no rows.");
                }

                var result = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);

                for (var x = 0; x < reader.FieldCount; x++)
                {
                    var fieldName = reader.GetName(x);

                    if (result.ContainsKey(fieldName))
                    {
                        throw new InvalidOperationException(Invariant($"Query results in two columns with the same name: {fieldName}."));
                    }

                    result.Add(fieldName, reader.IsDBNull(x) ? null : reader[x]);
                }

                if (reader.Read())
                {
                    throw new InvalidOperationException("Query results in more than one row.");
                }

                return result;
            }
            finally
            {
                reader.Close();
            }
        }

        private static void WriteToCsv(
            this SqlDataReader reader, 
            StreamWriter writer, 
            bool includeColumnNames)
        {
            try
            {
                if (reader.FieldCount == 0)
                {
                    throw new InvalidOperationException("A result set wasn't found when executing the command.  Command is a non-query.");
                }

                // write headers
                if (includeColumnNames)
                {
                    var headers = new List<string>();

                    for (var x = 0; x < reader.FieldCount; x++)
                    {
                        headers.Add(reader.GetName(x));
                    }

                    writer.Write(headers.ToCsv());
                }

                // write content
                while (reader.Read())
                {
                    var rowValues = new List<string>();

                    for (var x = 0; x < reader.FieldCount; x++)
                    {
                        if (reader.IsDBNull(x))
                        {
                            rowValues.Add(null);
                        }
                        else
                        {
                            var value = reader.GetValue(x);

                            // strings, chars, and char arrays need to be made CSV-safe.
                            // other datatypes are guaranteed to never violate CSV-safety rules.
                            if (value is string stringValue)
                            {
                                rowValues.Add(stringValue.ToCsvSafe());
                            }
                            else if (value is char)
                            {
                                rowValues.Add(value.ToString().ToCsvSafe());
                            }
                            else if (value is char[] charArrayValue)
                            {
                                rowValues.Add(charArrayValue.Select(_ => _.ToString(CultureInfo.InvariantCulture)).ToDelimitedString(string.Empty).ToCsvSafe());
                            }
                            else if (value is DateTime valueAsDate)
                            {
                                // DateTime.ToString() will truncate time.
                                var dateAsString = string.Empty;
                                if (valueAsDate.Kind == DateTimeKind.Unspecified)
                                {
                                    dateAsString = valueAsDate.ToString("yyyy-MM-dd HH:mm:ss.ffffff", CultureInfo.InvariantCulture);
                                }
                                else if (valueAsDate.Kind == DateTimeKind.Local)
                                {
                                    dateAsString = valueAsDate.ToString("yyyy-MM-dd HH:mm:ss.ffffffzzz", CultureInfo.InvariantCulture);
                                }
                                else if (valueAsDate.Kind == DateTimeKind.Utc)
                                {
                                    dateAsString = valueAsDate.ToString("yyyy-MM-dd HH:mm:ss.ffffffZ", CultureInfo.InvariantCulture);
                                }

                                rowValues.Add(dateAsString);
                            }
                            else
                            {
                                rowValues.Add(value.ToString());
                            }
                        }
                    }

                    writer.WriteLine();

                    // since we already treated strings for CSV-safety, use ToDelimitedString() instead of ToCsv()
                    writer.Write(rowValues.ToDelimitedString(","));
                }
            }
            finally
            {
                reader.Close();
            }
        }

        private static void ValidateForSqlParameterName(
            this string name)
        {
            new { name }.AsArg().Must().NotBeNullNorWhiteSpace();

            var nameWithoutAtSymbol = name.StartsWith("@") ? name.Substring(1) : name;

            if (!nameWithoutAtSymbol.IsAlphanumeric())
            {
                throw new ArgumentException("Parameter name is not alphanumeric (ignoring leading '@').");
            }
        }

        private static void ValidateForSqlDbType(
            this SqlDbType sqlDbType,
            IReadOnlyCollection<SqlDbType> validSqlDbTypes)
        {
            new { validSqlDbTypes }.AsArg().Must().ContainElement(sqlDbType);
        }
    }
}